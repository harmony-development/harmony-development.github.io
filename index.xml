<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Harmony</title>
    <link>https://harmonyapp.io/</link>
    <description>Recent content on Harmony</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 29 Jun 2020 21:07:15 -0400</lastBuildDate><atom:link href="https://harmonyapp.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://harmonyapp.io/protocol/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/protocol/readme/</guid>
      <description>Harmony Protocol This is the repository containing the Harmony protocol specification and documentation.
Read here for frequently asked questions.
To read about protocol conventions, please read GUIDELINES.
If you are looking for:
 a client to communicate with, check out Tempest, Challah or Crust. a server to host, check out Scherzo. an SDK to develop bots / clients / servers with, check out Rust SDK, Web SDK and C++ SDK.  Stable v.</description>
    </item>
    
    <item>
      <title>Harmony FAQ</title>
      <link>https://harmonyapp.io/docs/faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/docs/faq/</guid>
      <description>What is Harmony? A chat protocol which:
 is split into communities which contain channels which contain messages is defined entirely within the Protobuf format, using a simple RPC mechanism called hRPC.  What are the design goals of Harmony? Harmony&amp;rsquo;s protocol is designed to be as straightforward and pragmatic as possible. We do not make attempts at creating a &amp;ldquo;universal&amp;rdquo; design philosophy which the entire protocol is forced to follow, instead implementing things that make sense as a single cohesive system.</description>
    </item>
    
    <item>
      <title>Harmony FAQ</title>
      <link>https://harmonyapp.io/protocol/faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/protocol/faq/</guid>
      <description>What is Harmony? A chat protocol which:
 is split into communities which contain channels which contain messages is defined entirely within the Protobuf format, using a simple RPC mechanism called hRPC.  What are the design goals of Harmony? Harmony&amp;rsquo;s protocol is designed to be as straightforward and pragmatic as possible. We do not make attempts at creating a &amp;ldquo;universal&amp;rdquo; design philosophy which the entire protocol is forced to follow, instead implementing things that make sense as a single cohesive system.</description>
    </item>
    
    <item>
      <title>Permissions</title>
      <link>https://harmonyapp.io/docs/permissions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/docs/permissions/</guid>
      <description>The permissions system of Harmony resembles that of the permissions system common to open-source Minecraft server software, featuring rules and querying a node string against those rules.
Permission In a community, there will be features, management functionality, bot commands, and other things which exist. Most of these actions have a permission associated with them, allowing you to control which members have access to each feature.
A permission is just a string, such as roles.</description>
    </item>
    
    <item>
      <title>Permissions</title>
      <link>https://harmonyapp.io/protocol/stable/chat/v1/permissions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/protocol/stable/chat/v1/permissions/</guid>
      <description>The permissions system of Harmony resembles that of the permissions system common to open-source Minecraft server software, featuring rules and querying a node string against those rules.
Permission In a community, there will be features, management functionality, bot commands, and other things which exist. Most of these actions have a permission associated with them, allowing you to control which members have access to each feature.
A permission is just a string, such as roles.</description>
    </item>
    
    <item>
      <title>Protocol Guidelines</title>
      <link>https://harmonyapp.io/docs/guidelines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/docs/guidelines/</guid>
      <description>Protocol endpoints adhere to the following standard naming conventions:
  All actions being applied must be prefixed.
❌ What not to do:
 rpc ProfileUpdate(ProfileUpdateRequest) returns (ProfileUpdateResponse) {}  ✅ What to do:
 rpc UpdateProfile(UpdateProfileRequest) returns (UpdateProfileResponse) {}    Objects (types that aren&amp;rsquo;t request or response types) should go at the top of the file.
  Objects should not be nested inside request or response types.</description>
    </item>
    
    <item>
      <title>Protocol Guidelines</title>
      <link>https://harmonyapp.io/protocol/guidelines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/protocol/guidelines/</guid>
      <description>Protocol endpoints adhere to the following standard naming conventions:
  All actions being applied must be prefixed.
❌ What not to do:
 rpc ProfileUpdate(ProfileUpdateRequest) returns (ProfileUpdateResponse) {}  ✅ What to do:
 rpc UpdateProfile(UpdateProfileRequest) returns (UpdateProfileResponse) {}    Objects (types that aren&amp;rsquo;t request or response types) should go at the top of the file.
  Objects should not be nested inside request or response types.</description>
    </item>
    
    <item>
      <title>Reference: google.protobuf</title>
      <link>https://harmonyapp.io/docs/google.protobuf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/docs/google.protobuf/</guid>
      <description>Message Types FileDescriptorSet The protocol compiler can output a FileDescriptorSet containing the .proto files it parses.
Fields file (repeated google.protobuf.FileDescriptorProto) FileDescriptorProto Describes a complete .proto file.
Fields name (optional string) package (optional string) dependency (repeated string) Names of files imported by this file.
public_dependency (repeated int32) Indexes of the public imported files in the dependency list above.
weak_dependency (repeated int32) Indexes of the weak imported files in the dependency list. For Google-internal migration only.</description>
    </item>
    
    <item>
      <title>Reference: protocol.auth.v1</title>
      <link>https://harmonyapp.io/docs/protocol.auth.v1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/docs/protocol.auth.v1/</guid>
      <description>Message Types BeginAuthRequest Used in BeginAuth endpoint.
This item has no fields.
BeginAuthResponse BeginAuthResponse The return type of BeginAuth, containing the auth_id that will be used for the authentication section
Fields auth_id (optional string) auth_id: the ID of this auth session
Session Session Session contains the information for a new session; the user_id you logged in as and the session_token which should be passed to authorisation
Fields user_id (optional uint64) user_id: the ID of the user you logged in as</description>
    </item>
    
    <item>
      <title>Reference: protocol.batch.v1</title>
      <link>https://harmonyapp.io/docs/protocol.batch.v1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/docs/protocol.batch.v1/</guid>
      <description>Message Types AnyRequest AnyRequest is a generic message supporting any unary request.
Fields endpoint (optional string) The endpoint to which the request is being sent.
request (optional bytes) The request data.
BatchRequest Used in Batch endpoint.
Fields requests (repeated protocol.batch.v1.AnyRequest) The list of requests to be executed in the batch.
BatchResponse Used in Batch endpoint.
Fields responses (repeated bytes) The list of responses to the requests.
BatchSameRequest Used in BatchSame endpoint.</description>
    </item>
    
    <item>
      <title>Reference: protocol.chat.v1</title>
      <link>https://harmonyapp.io/docs/protocol.chat.v1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/docs/protocol.chat.v1/</guid>
      <description>Message Types Channel An object representing a channel, without the ID.
Fields channel_name (optional string) The name of this channel.
kind (UNHANDLED | TYPE) The kind of channel this is. Data does not get inherently stored in the Channel type Instead, clients who understand a certain ChannelKind should fetch them from a separate RPC.
metadata (optional protocol.harmonytypes.v1.Metadata) The metadata of this channel.
ChannelWithId The channel alongside with an ID.
Fields channel_id (optional uint64) ID of the channel.</description>
    </item>
    
    <item>
      <title>Reference: protocol.emote.v1</title>
      <link>https://harmonyapp.io/docs/protocol.emote.v1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/docs/protocol.emote.v1/</guid>
      <description>Message Types EmotePack Data for a single pack of emotes.
Fields pack_id (optional uint64) The ID of the pack.
pack_owner (optional uint64) The ID of the user who created the pack.
pack_name (optional string) The name of the pack.
Emote Data for a single emote.
Fields image_id (optional string) The image ID of the emote. This is the ID of the image in the image store (same place attachments are stored).</description>
    </item>
    
    <item>
      <title>Reference: protocol.harmonytypes.v1</title>
      <link>https://harmonyapp.io/docs/protocol.harmonytypes.v1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/docs/protocol.harmonytypes.v1/</guid>
      <description>Message Types HarmonyMethodMetadata Metadata for methods. These are set in individual RPC endpoints and are typically used by servers.
Fields requires_authentication (optional bool) whether the method requires authentication.
requires_local (optional bool) whether the method allows federation or not.
requires_permission_node (optional string) the permission nodes required to invoke the method.
requires_owner (optional bool) whether the method requires owner
Anything Anything holds anything
Fields kind (optional string) Kind is the kind of the message</description>
    </item>
    
    <item>
      <title>Reference: protocol.mediaproxy.v1</title>
      <link>https://harmonyapp.io/docs/protocol.mediaproxy.v1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/docs/protocol.mediaproxy.v1/</guid>
      <description>Message Types SiteMetadata Object representing the metadata of a website.
Fields site_title (optional string) Title of the website.
page_title (optional string) Page title of the website page.
kind (optional string) Kind of the website.
description (optional string) Description of the website page.
url (optional string) URL of the website.
image (optional string) A thumbnail image of the website.
MediaMetadata Object represeting the metadata of a media.
Fields mimetype (optional string) Mimetype of the media.</description>
    </item>
    
    <item>
      <title>Reference: protocol.profile.v1</title>
      <link>https://harmonyapp.io/docs/protocol.profile.v1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/docs/protocol.profile.v1/</guid>
      <description>Message Types OverrideTag A tag for an override. This is used as a standard shorthand for sending a message with an override. If a message starts with before and ends with after, clients should send a message with the override the tag belongs to, stripping the tag indicators.
Fields before (optional string) The portion of the tag before the messge.
after (optional string) The portion of the tag after the messge.</description>
    </item>
    
    <item>
      <title>Reference: protocol.sync.v1</title>
      <link>https://harmonyapp.io/docs/protocol.sync.v1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/docs/protocol.sync.v1/</guid>
      <description>Message Types AuthData Authentication data that will be sent in a harmonytypes.v1.Token.
Fields server_id (optional string) The server ID of the server initiating the transaction. For Pull, this tells the server being connected to which homeservers&#39; events it should send. For Push, this tells the server being connected to which homeservers&#39; events it is receiving.
time (optional uint64) The UTC UNIX time in seconds of when the request is started. Servers should reject tokens with a time too far from the current time, at their discretion.</description>
    </item>
    
    <item>
      <title>Reference: protocol.voice.v1</title>
      <link>https://harmonyapp.io/docs/protocol.voice.v1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/docs/protocol.voice.v1/</guid>
      <description>Message Types UserConsumerOptions Data containing all the necessary information to create a consumer for a user in a voice channel
This corresponds to https://mediasoup.org/documentation/v3/mediasoup-client/api/#ConsumerOptions on client:
 consumer_id -&amp;gt; id producer_id -&amp;gt; producerId rtp_parameters -&amp;gt; rtpParameters and kind should be set to &amp;ldquo;audio&amp;rdquo;.  Fields user_id (optional uint64) User ID of the user.
producer_id (optional string) Producer ID of the producer being consumed.
consumer_id (optional string) Consumer ID for the user&amp;rsquo;s producer consumer.</description>
    </item>
    
    <item>
      <title>RESTful Endpoints</title>
      <link>https://harmonyapp.io/docs/rest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/docs/rest/</guid>
      <description>Authentication If an endpoint expects authentication, the user should set the Authorization header to a valid token from the hRPC API.
POST /_harmony/media/upload Expects authentication: yes
The body should be POST-ed as a multipart form (multipart/form-data), with a single part named file which contains the body of the file being uploaded, the name of the file and the MIME type of the file.
Responses 200 OK The body will contain a JSON object in the following format:</description>
    </item>
    
    <item>
      <title>RESTful Endpoints</title>
      <link>https://harmonyapp.io/protocol/stable/rest/rest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/protocol/stable/rest/rest/</guid>
      <description>Authentication If an endpoint expects authentication, the user should set the Authorization header to a valid token from the hRPC API.
POST /_harmony/media/upload Expects authentication: yes
The body should be POST-ed as a multipart form (multipart/form-data), with a single part named file which contains the body of the file being uploaded, the name of the file and the MIME type of the file.
Responses 200 OK The body will contain a JSON object in the following format:</description>
    </item>
    
    <item>
      <title>Server Name Resolution</title>
      <link>https://harmonyapp.io/docs/name-resolution/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/docs/name-resolution/</guid>
      <description>Every Harmony homeserver is identified by a &amp;ldquo;server name.&amp;rdquo; A server name uniquely identifies a server, regardless of whether the resolved IP address changes or not. Two server names pointing to the same IP address would be considered two different homeservers.
A server name is resolved to an IP address and port using the following process:
When IP Address (xxx.xxx.xxx.xxx + optional :port) When the server name is an IP address, this is the resolved IP of the server that requests should be sent to.</description>
    </item>
    
    <item>
      <title>Server Name Resolution</title>
      <link>https://harmonyapp.io/protocol/stable/name-resolution/name-resolution/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://harmonyapp.io/protocol/stable/name-resolution/name-resolution/</guid>
      <description>Every Harmony homeserver is identified by a &amp;ldquo;server name.&amp;rdquo; A server name uniquely identifies a server, regardless of whether the resolved IP address changes or not. Two server names pointing to the same IP address would be considered two different homeservers.
A server name is resolved to an IP address and port using the following process:
When IP Address (xxx.xxx.xxx.xxx + optional :port) When the server name is an IP address, this is the resolved IP of the server that requests should be sent to.</description>
    </item>
    
  </channel>
</rss>
